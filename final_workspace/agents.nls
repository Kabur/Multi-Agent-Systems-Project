extensions [nw]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  beliefs
  path_type
  spawn_counter
  path_position
  path
  distress_stops
  traveling_to_signal
  spawn_later
  region
  claimed_distress_stop
  latest_bus_id
]
 
globals [graph counter] 

to init-buses
  ; Initialize your agents here.
  ; if it's the first bus ever, initialize one-time stuff
  ifelse bus_id = 24 [ 
    ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    initialize_bus "fixed" 1 []
    set latest_bus_id 24
  ]
  [ 
    set path_type "uninitialized"
  ]
end

to initialize_bus [initial_path_type initial_path initial_distress_stops]
  set path_type initial_path_type
  set path_position -1
  set spawn_counter 30
  set distress_stops initial_distress_stops
  show (list length distress_stops distress_stops)
  set traveling_to_signal false
  set spawn_later []
  set path []
  set region -1

  ifelse initial_path_type = "fixed" [
    set color blue
    ; todo: create different paths for these 3 regions
    if initial_path = 1 [
      ; let path_temp ["Centraal" "Dam" "Centraal" "Sloterdijk" "Lelylaan" "Amstelveenseweg" "VU" "Zuid" "RAI" "Amstel" "SciencePark" "UvA" "SciencePark" "Muiderpoort" 
      ; "Wibautstraat" "Museumplein" "Haarlemmermeerstation" "Surinameplein" "Evertsenstraat" "Leidseplein" "Weesperplein" "Waterlooplein" "Hendrikkade" "Hasseltweg" "Floradorp"  "Hasseltweg"  "Buikslotermeer" "Hasseltweg" "Hendrikkade"]
      ; foreach path_temp [
        ; set path lput bus_stop_name_to_id ? path
      ;
      set path [3 9 8 6 8 2 8 9 3 16 11 17 5 4]
      set region 1
    ]
    if initial_path = 2 [
      ; let path_temp ["Centraal" "Dam" "Centraal" "Sloterdijk" "Lelylaan" "Amstelveenseweg" "VU" "Zuid" "RAI" "Amstel" "SciencePark" "UvA" "SciencePark" "Muiderpoort" 
      ; "Wibautstraat" "Museumplein" "Haarlemmermeerstation" "Surinameplein" "Evertsenstraat" "Leidseplein" "Weesperplein" "Waterlooplein" "Hendrikkade" "Hasseltweg" "Floradorp"  "Hasseltweg"  "Buikslotermeer" "Hasseltweg" "Hendrikkade"]
      ; foreach path_temp [
        ; set path lput bus_stop_name_to_id ? path
      ; ]
      set path [3 20 21 22 0 15 18 15 12 20]
      set region 2
    ]
    if initial_path = 3 [
      ; let path_temp ["Centraal" "Dam" "Centraal" "Sloterdijk" "Lelylaan" "Amstelveenseweg" "VU" "Zuid" "RAI" "Amstel" "SciencePark" "UvA" "SciencePark" "Muiderpoort" 
      ; "Wibautstraat" "Museumplein" "Haarlemmermeerstation" "Surinameplein" "Evertsenstraat" "Leidseplein" "Weesperplein" "Waterlooplein" "Hendrikkade" "Hasseltweg" "Floradorp"  "Hasseltweg"  "Buikslotermeer" "Hasseltweg" "Hendrikkade"]
      ; foreach path_temp [
        ; set path lput bus_stop_name_to_id ? path
      ; ]    
      set path [3 4 10 13 7 1 19 23 14 23 13 10 4]
      set region 3
    ]
  ]
  [
    set color pink
  ]
  show (list "Initializing " initial_path_type initial_path path)
end



to-report get_next_stop 
  ; get next stop on path and report it
  let path_length length path
  set path_position (path_position + 1) mod path_length
  let nxt item path_position path

  ; needed for when the bus starts the path at the centraal
  ; if -1 is returned, we only have the current stop in our path --> stay where we are
  if (current_stop = nxt) [ 
    set nxt next_stop

    if (path_length > 1) 
      [ set nxt -1]
  ]
  show (word "next stop adding: ")
  show nxt
  report nxt
end


to-report drop_and_pick [cur_bus_stop cur_bus_passengers cur_bus_id capacity]
  
  ; current number of passengers
  let n_passengers length cur_bus_passengers
  
  ; get passengers waiting at current bus stop
  let waiting_passengers get-passengers-at-stop cur_bus_stop
   
  ; drop off people who want to go out at current stop
  foreach cur_bus_passengers [
     if item 1 ? = cur_bus_stop [
         drop-off-passenger item 0 ?
         show (list "dropping passenger " item 0 ?)
     ]  
  ]
   
  let still_at_stop []

  ; then get people that are waiting and are on the path
  foreach waiting_passengers [
    
    if n_passengers < capacity [
      let passenger_destination item 1 ?
      let is_on_path false

      ; iterate through the bus path to find if passengers' destination is on the path 
      foreach path [ 
        if passenger_destination = ? [
          set is_on_path true
        ]
      ]
      ; if the passenger is on the path -> pick him/her up
      ifelse is_on_path = true [
        pick-up-passenger item 0 ?
        set n_passengers n_passengers + 1
        show (list "Picking up passenger " ? "with destination: " passenger_destination)
      ]
      [
        ; take passengers if you are a freestyler and you have nowhere to go
        ifelse path_type = "freestyler" and empty? path and current_stop = claimed_distress_stop[
          set is_on_path true
          pick-up-passenger item 0 ?
          set n_passengers n_passengers + 1
        ]
        [
          set still_at_stop lput ? still_at_stop
          show (list "NOT picking up passenger " ? "with destination: " passenger_destination)
        ]
      ]

    ] 
  ]

  report still_at_stop
end

; ********************************************************************************
;                             EXECUTE ACTIONS - TOTAL SYSTEM
; ********************************************************************************
to execute-actions
  
  ; if a bus is not yet initialized, get info from inbox to initialize
  if path_type = "uninitialized" [
    ; if a message was received, use its info to initialize
    if length inbox > 0 [
      read-inbox
    ]
    ; breaks out of execute-actions
    stop
  ]

  show "***********************************************************************"
  let capacity get-capacity bus_type

  ; if there was a bus waiting to be initialized through a message(we called 'spawn' last tick)
  if length spawn_later > 0 [
    show spawn_later
    foreach spawn_later [
      show ?
      send-message item 0 ? item 1 ?
    ]
    set spawn_later []
  ]

  if length inbox > 0 [
	  read-inbox
  ]

  ; if we are at a bus_stop
  ifelse current_stop >= 0 [    
    show (list "we are at stop" current_stop " Current distress_stops list: " distress_stops)
    
    ; drop off people and pick up people 
    ; todo: do it twice because some passengers are retards and want to go to the same stop they are standing on
    let still_at_stop []
    set still_at_stop drop_and_pick current_stop bus_passengers bus_id capacity
        
    ifelse path_type = "fixed" [
      execute-actions-fixed still_at_stop
    ]
    ; else path_type = "freestyler"
    [
      execute-actions-freestyler
    ]

  ]
  [
    ; keep travelling to next stop
    travel-to next_stop
    if next_stop != -1 
      [ travel-to next_stop ]
  ]
  
  ; just spawn 3 buses right away
  let boss 24
  set spawn_counter spawn_counter - 1
  if bus_id = boss and spawn_counter = 0 [
    let new_bus_id spawn "fixed" 2 distress_stops
    let new_bus list item 0 new_bus_id item 1 new_bus_id
    let new_bus_id_2 spawn "fixed" 3 distress_stops
    let new_bus_2 list item 0 new_bus_id_2 item 1 new_bus_id_2
    set spawn_later lput new_bus spawn_later
    set spawn_later lput new_bus_2 spawn_later
    show (word "SPAWN LATER LIST")
    show spawn_later
  ]
  if bus_id = boss and spawn_counter = -30 [
    let new_bus_id spawn "freestyler" [] distress_stops
    set spawn_later lput new_bus_id spawn_later
    set spawn_counter 30
  ]
  
end


; ********************************************************************************
;                             EXECUTE ACTIONS -FREESTYLE BUSES
; ********************************************************************************
to execute-actions-freestyler
  
  ; remove var from path if we are at current stop 
    if length path > 0 and item 0 path = current_stop [
      set path remove-item 0 path
    ]
  
    ; if we were not following a distress signal(but rather transferring people from a signal), react to a signal
    ; Freestyler actions after dropping and picking people 
    ifelse traveling_to_signal = false [
      ; todo: COMPETITION: bidding for stops; Right now we'll just have the freestyler claim the next bus stop in distress in he queue
      show "We are at a bus stop; traveling_to_signal=false"
      set traveling_to_signal true
      ; if there are stops in distress, you finished your previous route and you dropped off people from previous distress stop: claim one and notify other freestylers]
      show (word "vars for if")
      show distress_stops
      show path
      show bus_passengers
      if length distress_stops > 0 and empty? path and empty? bus_passengers [
        
        let claimed_stop item 0 distress_stops
        set distress_stops remove-item 0 distress_stops

        let message []
        set message lput "Claiming bus stop in distress!" message
        set message lput claimed_stop message
        show message

        broadcast_message message

        ; dijkstra
        show (word "HIER")
        set path dijkstra current_stop claimed_stop
        set path remove-item 0 path
        set claimed_distress_stop claimed_stop
        show (word "HIERO")
      ]
      let dest -1
      if length path > 0 [
        set dest item 0 path
      ]
    
      if dest != -1 
        [ travel-to dest ]

    ]
    ; else, we were following a distress signal, initialize path based on where the people on the stop want to go
    ; todo: think carefully when drop_and_pick and path setting happens!
    [
      show "!!! We are at a bus stop, traveling_to_signal=true"
      set traveling_to_signal false
      
      ; if no path find path of passengers (else just travel to next place in path)
      if empty? path [
        ; (todo: NOT TESTED!) we now solve traveling salesman for the passengers destinations:
        ; get all destinations
        let waiting_passengers get-passengers-at-stop current_stop
        let destinations []
        foreach bus_passengers [
          set destinations lput item 1 ? destinations
        ]
        
        ; sort by distance to the current stop
        ;set destinations sort-on [distance current_stop] destinations
        
        
        ; build path throughout this sorted path with dijkstra
        let destinations_length length destinations
        let i 0
        show (word "destinations")
        show destinations
        
        let start_stop current_stop
        while [i < destinations_length] [
          
          let dijkstra_path dijkstra start_stop item i destinations
          set dijkstra_path remove-item 0 dijkstra_path
          foreach dijkstra_path [
            set path lput ? path
          ]
          show (word "will end at")
          show last path
          set start_stop last path
          set i i + 1
        ]
        show (word "PATH:")
        show path
      ]
      
      let dest -1
      ; travel to next stop in path
      if length path > 0 [
        set dest item 0 path
      ]
      
      if dest != -1 
        [ travel-to dest ]

    ]
end

; ********************************************************************************
;                             EXECUTE ACTIONS - FIXED BUSES
; ********************************************************************************
to execute-actions-fixed [people_left_at_stop]
  
  ; if there were people left, send a distress signal
  if length people_left_at_stop > 0 [
    let message []
    set message lput "Bus stop in distress!" message
    set message lput current_stop message

    ; send distress signal to everyone(gets filtered out to be unique in the queue at inbox checking)
    broadcast_message message

  ]

  let dest get_next_stop
  if dest != -1 [  
    travel-to dest 
    show (list "Traveling to " dest)
  ]
  
end

; ********************************************************************************
;                             HELPER FUNCTIONS
; ********************************************************************************
; to-report get_proximity [ stop_id ]
  ; 
; end


to read-inbox
  
  let read-messages false
  let full_message item 0 inbox
  let tick_sent item 0 full_message
  let sender item 1 full_message
  let message item 2 full_message  
  let message_type item 0 message
  set inbox remove-item 0 inbox
  
  if message_type = "Claiming bus stop in distress!" and read-messages = false [
    show (word  "claim")
    set read-messages true
  ]
  
  if (message_type =  "freestyler" or message_type = "fixed")  and read-messages = false [
    show (word "new")
    show message_type
    initialize_bus item 0 message item 1 message item 2 message
    set read-messages true
  ]
  
  if message_type = "Bus stop in distress!" and path_type = "freestyler" and read-messages = false [

    ; get the bus stop at distress
    let distress_stop item 1 message

    show (list "Received message: " message)

    ; add it to the queue of stops in distress if it's not already there
    if member? distress_stop distress_stops = false [
      show (list "Adding distress stop: " distress_stop)
      set distress_stops lput distress_stop distress_stops
    ]
    show (word "distress")
    set read-messages true
  ]
  
end


to-report spawn [initial_path_type initial_path initial_distress_stops]
  ; initial_path_type = "fixed" or "freestyler"
  ; initial_path = numbers from 1 to 3 if fixed; [] if freestyler

  add-bus 3
  let new_id latest_bus_id + 1

  ; send message to the new bus to initialize with parameters
  let message []
  set message lput initial_path_type message
  set message lput initial_path message
  set message lput initial_distress_stops message

  show (list "Sending to: " new_id " init message: " message)

  ; send-message new_id message ;this is now done at the beginning of the next execute-actions call
  set latest_bus_id new_id
  report (list new_id message)
end

to-report bus_stop_name_to_id [ string_name ]
  let id position string_name amsterdam_bus_stops_names

  report id
end

to-report get-capacity [bs_type]
  
  ; set bus capacity
  let capacity 0
  ifelse bs_type = 1 [
    set capacity 12
  ]
  [ 
    ifelse bs_type = 2 [
      set capacity 60
    ]
    [
      set capacity 150
    ]
  ]
  report capacity
end


to broadcast_message [message]

	let source_id bus_id
    let destination_id -1
    ask buses [
    	set destination_id bus_id
    	ask bus source_id [
    		send-message destination_id message
    		show (list "Sending message from " bus_id " to " destination_id " message: " message)
    	]
    ]

end

; ********************************************************************************
;                             HELPER FUNCTIONS
; ********************************************************************************
; ********************************************************************************
;                                PATH FINDING
; ********************************************************************************
to-report dijkstra [cur_stop claimed_stop]
  let shortest_path [] 
  let path_temp []
  ask bus_stop cur_stop [ set shortest_path nw:turtles-on-weighted-path-to bus_stop claimed_stop "route_size" ]

  ; convert turtles to id's
  foreach shortest_path [
    ask ? [
      let id_temp bus_stop_name_to_id name
      show (word "found path with dijkstra")
      show (list name id_temp) 
      set path_temp lput id_temp path_temp
    ]
  ]

  report path_temp
end


 ; to-report find_path_temp [destination fixed_path]
  ; let keep_appending true
  ; let temp_path []
; 
  ; foreach fixed_path [
    ; if keep_appending = true [
      ; set temp_path lput ? temp_path
; 
      ; if ? = destination [ 
        ; set keep_appending false 
      ; ]
; 
    ; ]
  ; ]
; 
  ; report temp_path
; end

; ********************************************************************************
;                                PATH FINDING
; ********************************************************************************
; note: renamed a bunch of things, such as 'routes' to 'paths' because route is a turtle type in their file 
; todo: try to split up the code into files, it must be possible like cmon
; todo: votin on spawning new buses / voting on disabling buses
; todo: bidding on who takes the stop at distress
; todo: when checking if passenger destination is on a freestyler's path, only consider future stops(freestylers don't drive sequentially)
; todo: create paths for the 3 regions
; todo: when a bus stop is claimed, fixed-routers should remove it from the list as well