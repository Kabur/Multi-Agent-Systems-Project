extensions [nw]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  beliefs
  path_type
  spawn_counter
  path_position
  inbox_position
  path
  distress_stops
  traveling_to_signal
  spawn_later
  region
  claimed_distress_stop
  latest_bus_id
]
 
globals [graph counter] 

to init-buses
  ; Initialize your agents here.
  ; if it's the first bus ever, initialize one-time stuff
  ifelse bus_id = 24 [ 
    ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
    set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
    initialize_bus "fixed" 1 []
    set latest_bus_id 24
    set inbox_position -1
  ]
  [ 
    set path_type "uninitialized"
    set inbox_position -1
    set spawn_later []
    set path []
    set distress_stops []
	set path_position 0 
	set spawn_counter 0
  ]
end

to initialize_bus [initial_path_type initial_region initial_distress_stops]
  set path_type initial_path_type
  set path_position 0 ; changed from -1
  set spawn_counter 0
  set distress_stops initial_distress_stops
  show (list "Initializing " initial_path_type "distress stops:" distress_stops)
  set traveling_to_signal false
  set spawn_later []
  set path []
  set region -1

  ifelse initial_path_type = "fixed" [
    set color blue
    if initial_region = 1 [
      set path [3 9 8 6 8 2 8 9 3 16 11 17 5 4]
      set region 1
    ]
    if initial_region = 2 [
      set path [3 20 21 22 0 15 18 15 12 20]
      set region 2
    ]
    if initial_region = 3 [
      set path [3 4 10 13 7 1 19 23 14 23 13 10 4]
      set region 3
    ]
  ]
  [
    set color pink
  ]
end



to-report get_next_stop 
  ; get next stop on path and report it
  let path_length length path
  set path_position (path_position + 1) mod path_length
  let nxt item path_position path

  ; needed for when the bus starts the path at the centraal
  ; if -1 is returned, we only have the current stop in our path --> stay where we are
  if (current_stop = nxt) [ 
    set nxt next_stop
    ; set nxt get_next_stop

    if (path_length > 1) 
      [ set nxt -1]
  ]
  ; show (list "next stop adding: " nxt)
  report nxt
end


to-report drop_and_pick [cur_bus_stop cur_bus_passengers cur_bus_id capacity]
  
  ; current number of passengers
  let n_passengers length cur_bus_passengers
  
  ; get passengers waiting at current bus stop
  let waiting_passengers get-passengers-at-stop cur_bus_stop
   
  ; drop off people who want to go out at current stop
  foreach cur_bus_passengers [
     if item 1 ? = cur_bus_stop [
         drop-off-passenger item 0 ?
         show (list "DROPPING passenger " item 0 ? "with destination: " item 1 ?)
     ]  
  ]
   
  let still_at_stop []

  ; then get people that are waiting and are on the path
  foreach waiting_passengers [
    
    if n_passengers < capacity [
      let passenger_destination item 1 ?
      let is_on_path false

      ; iterate through the bus path to find if passengers' destination is on the path 
      foreach path [ 
      	; show (list "!!!DEBUGGGG... position ? path:" position ? path "path_position:" path_position "passenger_destination:" passenger_destination)
        ; for freestylers, only consider the FUTURE stops in the path because they do not repeat the path
        if path_type = "fixed" or position ? path >= path_position [
          if passenger_destination = ? [
            set is_on_path true
          ]
        ]
      ]
      ; if the passenger is on the path -> pick him/her up
      ifelse is_on_path = true [
        pick-up-passenger item 0 ?
        set n_passengers n_passengers + 1
        show (list "Picking up passenger " ? "with destination: " passenger_destination)
      ]
      [
        ; take passengers if you are a freestyler and you have nowhere to go
        ; ifelse path_type = "freestyler" and empty? path and current_stop = claimed_distress_stop[
          ; set is_on_path true
          ; pick-up-passenger item 0 ?
          ; set n_passengers n_passengers + 1
        ; ]
        ; [
          set still_at_stop lput ? still_at_stop
          show (list "NOT picking up passenger " ? "with destination: " passenger_destination)
        ; ]
      ]

    ] 
  ]

  report still_at_stop
end

; ********************************************************************************
;                             EXECUTE ACTIONS - TOTAL SYSTEM
; ********************************************************************************
to execute-actions
  ; let temp_var minutes + hours * 60
  show (list (minutes + hours * 60) "***********************************************************************")
  ; show (list "inbox position: " inbox_position)

  ; order of these 3 is important!
  ; send init messages to spawned buses
  if path_type != "uninitialized" [ resolve_spawning ]
  ; read inbox, update distress_stops, (freestylers get spawn there too)
  read_inbox
  ; if we didnt receive our init message yet, wait
  if path_type = "uninitialized" [ stop ]

  ; if we are at any bus_stop
  ifelse current_stop >= 0 [    
    show (list "we are at stop" current_stop " Current distress_stops:" distress_stops "Current path:" path "path_position: " path_position)
    
    ; drop off people and pick up people 
    let still_at_stop []
    set still_at_stop drop_and_pick current_stop bus_passengers bus_id get-capacity bus_type
        
    ; decide what to do next
    ifelse path_type = "fixed" [
      execute-actions-fixed still_at_stop
    ]
    [
      execute-actions-freestyler
    ]

  ]
  ; else we are NOT on a bus stop -> keep driving
  [
    travel-to next_stop
  ]
  
  set spawn_counter spawn_counter + 1
  
end


; ********************************************************************************
;                             EXECUTE ACTIONS -FREESTYLE BUSES
; ********************************************************************************
to execute-actions-freestyler
  
    ; if we were not following a distress signal(but rather transferring people from a signal), react to a signal
    ; Freestyler actions after dropping and picking people 
    ifelse traveling_to_signal = false [
      show (list "traveling_to_signal=false, path: " path "path_position: " path_position)

      ; if we finished the path, but there are no distress stops, wait
      if length distress_stops = 0 and length path - 1 <= path_position [ stop ]

      ; if there are stops in distress and you finished your path, claim a stop
	      ; if we are NOT at the end of our path, just continue to the next stop
      if length distress_stops > 0 and length path - 1 <= path_position [ ;note: length path = 0 when we just initialized this guy
        set traveling_to_signal true
        set path_position 0
        let claimed_stop item 0 distress_stops

        let message []
        set message lput "Claiming bus stop in distress!" message
        set message lput claimed_stop message

        broadcast_message message

        ; dijkstra
        set path dijkstra current_stop claimed_stop
        show (list "Sending claiming message:" message "new path: " path)

        ; drop&picking with respect to the new path
	    let void drop_and_pick current_stop bus_passengers bus_id get-capacity bus_type
      ]

      let dest get_next_stop
      if dest != -1 [  
        travel-to dest 
        show (list "Traveling to " dest)
      ]

    ]
    ; else, we were following a distress signal, initialize path based on where the people on the stop want to go
    [
      show (list "traveling_to_signal=true, path: " path "path_position: " path_position)
    
      ; if we are at the end of our path, calculate a new path based on passengers wishes
      	; if not, just continue on our path
      if length path - 1 <= path_position [
	    set traveling_to_signal false

        ; Solve traveling salesman for the passengers destinations:
        ; get all destinations
        let waiting_passengers get-passengers-at-stop current_stop
        let destinations []
        foreach waiting_passengers [
          set destinations lput item 1 ? destinations
        ]

        ; sort by distance to the current stop
        set destinations sort-by [get_distance_to_current_stop ?1 < get_distance_to_current_stop ?2] destinations
        
        ; build path throughout this sorted path with dijkstra
	    set path_position 0 
	    set path []
        let destinations_length length destinations
        let i 0 
        
        let start_stop current_stop
        set path lput start_stop path
        while [i < destinations_length] [
          
          let dijkstra_path dijkstra start_stop item i destinations

          set dijkstra_path remove-item 0 dijkstra_path
          foreach dijkstra_path [
            set path lput ? path
          ]
          set start_stop last path
          set i i + 1
        ]

        show (list "new path:" path)

        ; drop&picking with respect to the new path
	    let void drop_and_pick current_stop bus_passengers bus_id get-capacity bus_type
      ]
      
      let dest get_next_stop
      if dest != -1 [  
        travel-to dest 
        show (list "Traveling to " dest)
      ]

    ]
end

; ********************************************************************************
;                             EXECUTE ACTIONS - FIXED BUSES
; ********************************************************************************
to execute-actions-fixed [people_left_at_stop]
  
  ; if there were people left, send a distress signal
  if length people_left_at_stop > 0 [
    let message []
    set message lput "Bus stop in distress!" message
    set message lput current_stop message

    ; send distress signal to everyone(gets filtered out to be unique in the queue at inbox checking)
    broadcast_message message

  ]

  let dest get_next_stop
  if dest != -1 [  
    travel-to dest 
    ; show (list "Traveling to " dest)
  ]
  
end

; ********************************************************************************
;                             	INBOX MANAGEMENT
; ********************************************************************************
to broadcast_message [message]
	let source_id bus_id
    let destination_id -1
    ask buses [
    	set destination_id bus_id
    	ask bus source_id [
    		send-message destination_id message
    		; show (list "Broadcasting message from " bus_id " to " destination_id " message: " message)
    	]
    ]
end


to read_inbox
  
  ; show (list "inbox: " inbox)
  let inbox_length length inbox
  ifelse inbox_length - 1 > inbox_position [ 
    set inbox_position inbox_position + 1 
    ; show (list "inbox_position: " inbox_position)
  ]
  [ stop ]

  let read_messages false
  let full_message item inbox_position inbox
  let tick_sent item 0 full_message
  let sender item 1 full_message
  let message item 2 full_message  
  let message_type item 0 message
  

  if message_type = "Claiming bus stop in distress!" and read_messages = false [
    ; remove the claimed stop from the list
    let distress_stop item 1 message
    show (list "Received claiming message: " message "distress_stops: " distress_stops)

    if member? distress_stop distress_stops = true [
      let temp_pos position distress_stop distress_stops
      set distress_stops remove-item temp_pos distress_stops
      show (list "Removed a distress stop; new list: " distress_stops)
    ]

    set read_messages true
  ]
  

  if (message_type =  "freestyler" or message_type = "fixed")  and read_messages = false [
    ; show (word "new")
    show message_type
    initialize_bus item 0 message item 1 message item 2 message
    set read_messages true
  ]
  

  ; if message_type = "Bus stop in distress!" and path_type = "freestyler" and read_messages = false [
  if message_type = "Bus stop in distress!" and read_messages = false [

    ; get the bus stop at distress
    let distress_stop item 1 message

    show (list "Received distress message: " message "distress_stops: " distress_stops)

    ; add it to the queue of stops in distress if it's not already there
    if member? distress_stop distress_stops = false [
      show (list "Adding distress stop: " distress_stop)
      set distress_stops lput distress_stop distress_stops
      ; if this is the boss and a new distress stop was added, spawn a freestyler
      if bus_id = 24 and spawn_counter >= 30 [
        set spawn_counter 0
        show (list "Spawning a freestyler; distress_stops: " distress_stops)
        let new_bus_id spawn "freestyler" [] distress_stops
        set spawn_later lput new_bus_id spawn_later
      ]
    ]

    ; show (list "Distress stops: " distress_stops)
    set read_messages true
  ]
  
end

; ********************************************************************************
;                             HELPER FUNCTIONS
; ********************************************************************************
to resolve_spawning
  if length spawn_later > 0 [
    show (list "spawn_later: " spawn_later)
    foreach spawn_later [
      ; show ?
      send-message item 0 ? item 1 ?
      show (list "Sending init message to: " ?)
    ]
    set spawn_later []
  ]

  ; spawn the remaining 2 region buses at the beginning
  if count buses = 1 [
    let new_bus_id spawn "fixed" 2 distress_stops
    let new_bus list item 0 new_bus_id item 1 new_bus_id
    let new_bus_id_2 spawn "fixed" 3 distress_stops
    let new_bus_2 list item 0 new_bus_id_2 item 1 new_bus_id_2
    set spawn_later lput new_bus spawn_later
    set spawn_later lput new_bus_2 spawn_later
    ; show (word "SPAWN LATER LIST")
    show (list "spawn_later: " spawn_later) 
  ]
end

to-report spawn [initial_path_type initial_region initial_distress_stops]
  ; initial_path_type = "fixed" or "freestyler"
  ; initial_region = numbers from 1 to 3 if fixed; [] if freestyler

  add-bus 3
  let new_id latest_bus_id + 1

  ; send message to the new bus to initialize with parameters
  let message []
  set message lput initial_path_type message
  set message lput initial_region message
  set message lput initial_distress_stops message

  ; send-message new_id message ;this is now done at the beginning of the next execute-actions call
  set latest_bus_id new_id
  report (list new_id message)
end

to-report bus_stop_name_to_id [ string_name ]
  let id position string_name amsterdam_bus_stops_names

  report id
end

to-report get-capacity [bs_type]
  
  ; set bus capacity
  let capacity 0
  ifelse bs_type = 1 [
    set capacity 12
  ]
  [ 
    ifelse bs_type = 2 [
      set capacity 60
    ]
    [
      set capacity 150
    ]
  ]
  report capacity
end

to-report id_to_bus_stop [temp_id]
	let temp_busstop "Empty"

	ask bus_stop temp_id [
		set temp_busstop self
	]

	report temp_busstop
end

to-report id_to_bus_stop_list [temp_id_list]
	let temp_list []

	foreach temp_id_list [
		ask bus_stop ? [
			set temp_list lput self temp_list
		]
	]

	report temp_list
end

to-report get_distance [source_stop dest_stop]
	let temp_dist 0
	ask bus_stop source_stop [ set temp_dist distance id_to_bus_stop dest_stop]

	report temp_dist 
end

to-report get_distance_to_current_stop [dest_stop]
	let temp_dist 0
	ask bus_stop current_stop [ set temp_dist distance id_to_bus_stop dest_stop]

	report temp_dist 
end
; ********************************************************************************
;                                PATH FINDING
; ********************************************************************************
to-report dijkstra [cur_stop claimed_stop]
  let shortest_path [] 
  let path_temp []
  ask bus_stop cur_stop [ set shortest_path nw:turtles-on-weighted-path-to bus_stop claimed_stop "route_size" ]

  ; convert turtles to id's
  foreach shortest_path [
    ask ? [
      let id_temp bus_stop_name_to_id name
      ; show (word "found path with dijkstra")
      ; show (list name id_temp) 
      set path_temp lput id_temp path_temp
    ]
  ]

  report path_temp
end


; ********************************************************************************
;                               NOTES AND TODOS
; ********************************************************************************
; todo (IMPORTANT): read ALL messages in read_inbox, not just one
; todo: try to split up the code into files
; todo: votin on spawning new buses / voting on disabling buses
; todo: bidding on who takes the stop at distress

; note: when submitting final, change the color to what it was previously
; note: we never remove stuff from path, we just move path_position to keep track of where we are!
; note: use show (list stuff "more suff") to print multiple things in 1 line
; note: use _ instead of - in functions
; note: the freestyler just waits if there are no distress_stops for now
