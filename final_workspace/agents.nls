extensions [nw]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  
  ; variables for all buses
  inbox_position  ; pointer denoting which messages are already read and which are unread
  path_type       ; type of bus: can be fixed or free
  path            ; list containing traveling path of bus
  spawn_counter   ; counter that is set to zero each time a new bus is spawned and increments every tick, can only spawn new buses if counter is above some number (hyperpar)
  
  ; region leader variables, only these region leaders can spawn buses
  init_later      ; list of buses to initialize later but that are already spawned
  latest_bus_id   ; necessary for buses that can spawn to know which new bus should be spawned
  my_buses        ; list of bus ids of busen in the leaders region (necessary for voting)
  votes           ; list with entry per bus from my_buses, entries can be 0 or 1 denoting no or yes vote
  region_leader_ids ; list with ids of region leaders to send messages to when spawning bus to let them know they should update their latest_bus_id
  freestylers     ; region leaders need list of freestylers to send them a message with the current distress stops and their colleague freestylers when they initialized
  
  ; region buses
  path_position   ; index of position in path of bus
  region          ; integer denoting region (1,2,3)
  last_capacity   ; capacity of bus when last voted
  my_region_leader; id of region leader to send votes to
  
  ; freestyle buses
  distress_stops  ; list of bus stops that are in 'distress' (people left at stop by buses)
  traveling_to_signal ; signal that is true if a bus if traveling to a distress signal, false if he is not
  current_bid     ; bus' current bid for a distress stop
  current_bid_stop; bus' current stop he is bidding on
  bids            ; list of bids from other buses (needed to check if own bid is the lowest)
  bids_stops      ; list denoting which distress stop the bids from buses-own variable 'bids' are on (needed to know which bids to compare own bid with, should always bid on same stop)
  bidding_round   ; can only bid once per tick so this bidding_round is set to true when a bus already bid in a round, reset to false after bids are compared (needed because there are several distress stops and can only bid on 1 in 1 tick)
]
 
globals [graph]

; ********************************************************************************************************************************************************************
;                                READ FIRST !
; ********************************************************************************************************************************************************************
; since everyone can only use their own information right now stuff is a little more complicated, I implemented as follow:
; first region leaders are initialized by bus 24, nt at the same time because then updating ids gets messy
; all region leaders need a list of other region leaders ids since they are all allowed to spawn new region buses based on votes and they need to update eachother on the newest id of the latest bus through messages
; whenever a new region leader gets spawned it initializes with the previous leaders as init variable and sends a new message to the previous leaders letting them know hes here so they add him to their ids
; whenever a regular region bus gets spawned by a leader, the leader also keeps track of the id in a list to remember all its region buses
; whenever a bus gets spawned in general the region leader who spawned lets the other leaders know so they can update their latest_bus_id
; whenever a freestyle bus gets spawned it sends a message back to the leader that spawned it when it is ready (or initialized) and that leader then tells the other leaders about the new freestyle bus
; whenever a leader gets a message that there is a new initialized freestyler, it sends that freestyler a welcome message with all the old freestylers to make sure the new freestyler knows who its colleagues are (for claiming bus stops)
; and he sends a message to the current freestylers about their new colleague so they can update their list of freestylers as well
; the freestyle buses method of driving is the same and the region method as well
; ********************************************************************************************************************************************************************
;                                SPAWNING & INITIALIZING
; ********************************************************************************************************************************************************************

to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ; first bus already spawned so only initialize its variables
  ifelse bus_id = 24 [
    set region_leader_ids (list bus_id)
    initialize-bus "fixed" 1 [] 24 region_leader_ids true
    set path [3 9 8 6 8 2 8 9 3 16 11 17 5 4]
  ]
  ; other buses will be initialized later
  [
    set path_type "unintialized"
    set path []
    set region_leader_ids []
  ]
  
  ; initial variables all buses
  set inbox_position -1
  
  ; initial variables region buses
  set path_position 0
  
  ; initial variables region leaders
  set init_later []
  set latest_bus_id bus_id
  set freestylers []
  
  ; initial variables freestyle buses
  set distress_stops []
  set bids []
  set bids_stops []
  set bidding_round false
  set current_bid 1000000
  set current_bid_stop -1
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that initializes a bus according to several variables
; the bus got this variables through an init message which was sent from function 'spawn', read from inbox and sent to this function
; this init message contained all information the bus needed to initialize correctly
; VARIABLES:
; initial_path_type: denoting whether its a free or region bus
; initial_region: which region it drives
; initial_freestylers: what freestylers already exist in the system
; my_leader: who is my region leader
; current_leaders: what are the current other leaders
; leader: a bool denoting if I should be a leader
to initialize-bus [initial_path_type initial_region initial_freestylers my_leader current_leaders leader]
  
  ; set variables necessary for all buses
  set path_type initial_path_type
  set freestylers initial_freestylers
  set bids n-values (length freestylers) [1000000]
  set bids_stops n-values (length freestylers) [-1]
  set my_region_leader my_leader
  
  ; if path type is fixed, set route, region and color
  ifelse initial_path_type = "fixed" [
    let capacity get-capacity bus_type
    set last_capacity capacity
    set my_buses (list bus_id)
    set votes (list 0)
    set color blue
    if initial_region = 1 [
      set path [3 9 8 6 8 2 8 9 3 16 11 17 5 4]
      set region 1
      set color blue
    ]
    if initial_region = 2 [
      set path [3 20 21 22 0 15 18 15 12 20]
      set region 2
      set color green
    ]
    if initial_region = 3 [
      set path [3 4 10 13 7 1 19 23 14 23 13 10 4]
      set region 3
      set color red
    ]
    
    ; if bus is a leader
    if leader = true [
      
      ; add old leaders to my variable
      foreach current_leaders [
        if member? ? region_leader_ids = false [
          set region_leader_ids lput ? region_leader_ids
        ]
      ]
      
      ; add my id to my variable if its not already thre
      if member? bus_id region_leader_ids = false [
        set region_leader_ids lput bus_id region_leader_ids
      ]
      
      ; send message to current leaders to tell them to add new leader to their region_leader_ids
      foreach current_leaders [
        let message (list "new leader" bus_id)
        send-message ? message
      ]
    ]
  ]
  ; if path type is free
  [
    
    ; send message to a leader that I am ready initializing and color me pink
    let message (list "ready" bus_id)
    set traveling_to_signal false
    send-message my_region_leader message
    set color pink
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that spawns new buses based on several variables
; VARIABLES:
; new_id: id of bus to spawn
; initial_path_type: fixed or free
; initial_region: 1,2,3 or -1 if not fixed
; current_freestylers: list of freestyler buses already in system
; leader_bool: boolean thats true if a leader has to be spawned, false otherwise
; current_leaders: list of current leaders in system
; leader_id: bus id of region leader for new bus
to-report spawn [new_id initial_path_type initial_region current_freestylers leader_bool current_leaders leader_id]
  ; initial_path_type = "fixed" or "freestyler"
  ; initial_region = numbers from 1 to 3 if fixed; [] if freestyler
  
  ; add bus of type 3
  add-bus 3
  
  ; send message to update other region leaders to notify them of a new latest bus id
  let update_id_message (list "update id" new_id)
  foreach region_leader_ids [
    let leader ?
    send-message leader update_id_message
  ]
  
  ; get my leader
  let my_leader leader_id
  
  ; add my id to leaders
  if leader_bool = true [
    set current_leaders lput new_id current_leaders
  ]

  ; send message to the new bus to initialize with parameters
  let message (list "init" initial_path_type initial_region current_freestylers my_leader current_leaders leader_bool)
  
  ; send-message new_id message ;this is now done at the beginning of the next execute-actions call
  report (list new_id message)
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function loops over buses that have to be initialized in the variable init_later and sends these buses init messages
to resolve-spawning
  
  ; if there are buses to be spawned
  if length init_later > 0 [
    
    ; loop over them and initialize
    foreach init_later [
      
      let spawn_info ?
      
      ; first item spawn_info is id of bus to be spawned second item is info about that bus
      send-message item 0 spawn_info item 1 spawn_info
    ]
    
    ; all buses spawned so reset list containing buses to spawn
    set init_later []
  ]
   
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that spawns region leaders with their correct settings of variables by adding them to the list to initialize later ('init_later')
; VARIABLES:
; no: region to spawn leader for (1,2 or 3)
to spawn-region-leaders [no]
  
  ; spawn the remaining 2 region buses at the beginning
  let region_leader spawn (latest_bus_id + 1) "fixed" no freestylers true region_leader_ids (latest_bus_id + 1)
  
  ; send the buses to init_later
  set init_later lput region_leader init_later
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that spawns new region leaders with their correct settings of variables by adding them to the list to initialize later ('init_later')
; VARIABLES:
; region_num: region the bus will drive
; my_leader: id of the region leader for the bus
to spawn-region-buses [region_num my_leader]
  
  set my_buses lput (latest_bus_id + 1) my_buses
  set votes lput 0 votes
  let region_bus spawn (latest_bus_id + 1) "fixed" region_num freestylers false [] my_leader
  set init_later lput region_bus init_later
  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that spawns new freestyle buses with their correct settings of variables by adding them to the list to initialize later ('init_later')
; VARIABLES:
; region_leader: id of region_leader 
; (needed because the new free bus will send the region leader a message when he is ready initializing (after function initialize-bus) 
; after which the region leader will let him know what the currect distress stops are and who his colleagues are, which is needed because in one tick multiple region leaders can spawn free buses)
; current_freestylers: list of current_freestylers
to spawn-freestyle-buses [region_leader current_freestylers]
  
  let freestyle_bus spawn (latest_bus_id + 1) "free" -1 [] false current_freestylers region_leader
  
  set init_later lput freestyle_bus init_later
  
end

; ********************************************************************************************************************************************************************
;                                EXECUTE ACTIONS - TOTAL SYSTEM
; ********************************************************************************************************************************************************************

to execute-actions
  
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; always first read inbox to update bus ids etc.
  read-inbox
  
  ; if a bus coming into execute actions wit its path type unitialized, this means that this is the first ticks for this bus and it needs to be initialized
  if path_type != "uninitialized" [ resolve-spawning ]
  
  if path_type = "fixed" [
    cast-vote
  ]
  
  ; count votes if youre a region leader
  if bus_id = my_region_leader [
    count-votes
  ]
  
  ; if we are at a stop
  ifelse current_stop >= 0 and path_type != "uninitialized" [
    
    ifelse path_type = "fixed" [
      actions-region-buses 
    ]
    [
      if path_type = "free" [
        actions-freestyle-buses
      ]
    ]    
  ]
  [
    if next_stop != -1 and path_type != "uninitialized" [
      travel-to next_stop
    ]
  ]
  
  ; initialize first 2 region leaders
  if count buses = 1 and bus_id = 24 [
    spawn-region-leaders 2
  ]
  if count buses = 2 and bus_id = 24 and ticks = 5 [
    spawn-region-leaders 3
  ]
  
  ; CHANGE THIS; TEMPORARY
  if (minutes = 15 or ticks = 60) and member? bus_id region_leader_ids = true and spawn_counter >= 30 [
    
    ; spawn a freestyler, this freestyler will automatically be added, and initialized, 
    ; if hes ready initializing, he will send a message to the region leader that he is ready, 
    ; this region leader will notify his colleagues and the other existing freestylers that hes ready
    spawn-freestyle-buses bus_id freestylers
    
    set spawn_counter 0
  ]
  
  ; TEMPORARY AS WELL CHECKING IF IT HELPS (answer: no)
  if ticks = 90 and member? bus_id region_leader_ids = true [
    spawn-region-buses region bus_id
    set spawn_counter 0
  ]
  
  if ticks = 120 and member? bus_id region_leader_ids = true [
    spawn-region-buses region bus_id
    set spawn_counter 0
  ]
  
  if ticks = 130 and member? bus_id region_leader_ids = true [
    spawn-region-buses region bus_id
    set spawn_counter 0
  ]
  
  set spawn_counter spawn_counter + 1  
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that executes all actions for region buses
to actions-region-buses
  ;show (word "exec region")
  ; drop people off and pick people up
  let capacity get-capacity bus_type
  let people_left_at_stop drop-and-pick current_stop bus_passengers bus_id capacity
  
  ; if there were people left, send a distress signal
  ifelse length people_left_at_stop > 90 [
    let message (list "distress" current_stop "extra")
    ; send distress signal to freestylers
    send-to-freestylers message
  ]
  [
    if length people_left_at_stop > 0 [
      let message (list "distress" current_stop "")
      ; send distress signal to freestylers
      send-to-freestylers message
    ]
  ]
  ; get next stop and travel to it
  get-next-stop
  if next_stop != -1 and path_type != "uninitialized" [
    travel-to next_stop
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that executes all actions for freestyle buses
to actions-freestyle-buses
  ;show (list "bidding round" bidding_round)
  
  ifelse bidding_round = false [
    ;show (list "distress stops" distress_stops)
    if length distress_stops > 0 [
      let stress_stop item 0 distress_stops
      let bid calculate-bid stress_stop
      bidding bid stress_stop
      ;show (list "bid from " bus_id " is " bid " because path is " path " path position is " path_position " and distress stop is " stress_stop)
      set current_bid bid
      set current_bid_stop stress_stop
      set bidding_round true
    ]
  ]
  [
    ;show (list "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
    ;show (list "current bids " bids " my bid " current_bid " for stop " current_bid_stop)
    ;show (list "for stops    " bids_stops)
    let ctr 0
    let winning_bidder true
    foreach bids_stops [
      if current_bid_stop = ? [
        let his_bid item ctr bids
        if his_bid < current_bid [
          set winning_bidder false
        ]
      ]
      set ctr ctr + 1
    ]
    if winning_bidder = true and length distress_stops > 0 [
      let claimed_stop_idx position current_bid_stop distress_stops
      if claimed_stop_idx != false [
        let claimed_stop item claimed_stop_idx distress_stops
        set traveling_to_signal true
        let claiming_message (list "claim" claimed_stop)
        ;show (list "claiming distress stop: " claimed_stop)
        send-to-freestylers claiming_message
        set distress_stops remove-item 0 distress_stops
        
        ; dijkstra
        ifelse length path = 0 [
          set path dijkstra current_stop claimed_stop
        ]
        [
          let last_stop last path
          let temp_path dijkstra last_stop claimed_stop
          set temp_path remove-item 0 temp_path
          foreach temp_path [
            set path lput ? path
          ]
        ]
        ;show (list "claimed stop so new path is " path)
      ]
      
    ]
    let n_bidders length bids
    set bids n-values n_bidders [1000000]
    set bids_stops n-values (length freestylers) [-1]
    set bidding_round false
  ]
    
    
  ; if we were not following a distress signal(but rather transferring people from a signal), react to a signal
    ; Freestyler actions after dropping and picking people 
    ifelse traveling_to_signal = false [
    
      ; if we finished the path, but there are no distress stops, wait
      if length distress_stops = 0 and length path - 1 <= path_position [ stop ]
      
      ; if there are stops in distress and you finished your path, claim a stop
      ; if we are NOT at the end of our path, just continue to the next stop
      if length distress_stops > 0 and length path - 1 <= path_position [ ;note: length path = 0 when we just initialized this guy
        
        set path_position 0
        
        if length path > 0 [
          if item 0 path = current_stop [
            set path remove-item 0 path
            if length path = 0 [
              set traveling_to_signal false
            ]
          ]
          ; drop&picking with respect to the new path
          let void drop-and-pick current_stop bus_passengers bus_id get-capacity bus_type
        ]
        
      ]
      
      get-next-stop
      
      if next_stop != -1 and path_type != "uninitialized" [  
        travel-to next_stop
      ]

    ]
    ; else, we were following a distress signal, initialize path based on where the people on the stop want to go
    [

      ; if we are at the end of our path, calculate a new path based on passengers wishes
      ; if not, just continue on our path
      if length path - 1 <= path_position [
        set traveling_to_signal false
        
        ; Solve traveling salesman for the passengers destinations:
        ; get all destinations
        let waiting_passengers get-passengers-at-stop current_stop
        let destinations []
        foreach waiting_passengers [
          set destinations lput item 1 ? destinations
        ]
        
        ; sort by distance to the current stop
        set destinations sort-by [get-distance-to-current-stop ?1 < get-distance-to-current-stop ?2] destinations
        
        ; build path throughout this sorted path with dijkstra
        set path_position 0 
        set path []
        let destinations_length length destinations
        let i 0 
        
        let start_stop current_stop
        set path lput start_stop path
        while [i < destinations_length] [
          
          let dijkstra_path dijkstra start_stop item i destinations
          
          set dijkstra_path remove-item 0 dijkstra_path
          foreach dijkstra_path [
            set path lput ? path
          ]
          set start_stop last path
          set i i + 1
        ]
        
        if item 0 path = current_stop [
          set path remove-item 0 path
        ]
      ]
      
      ; drop&picking
      let passengers_left drop-and-pick current_stop bus_passengers bus_id get-capacity bus_type
      ifelse length passengers_left > 90 [
       ; show (list "at bus stop " current_stop " " (length passengers_left) " are still waiting")
        let message (list "distress" current_stop "extra")
        ; send distress signal to freestylers
        send-to-freestylers message
      ]
      [
        if length passengers_left > 0 [
          ;show (list "at bus stop " current_stop " " (length passengers_left) " are still waiting")
          let message (list "distress" current_stop "")
          ; send distress signal to freestylers
          send-to-freestylers message
        ]
      ]
      
      get-next-stop
      if next_stop != -1 and path_type != "uninitialized" [  
        travel-to next_stop
      ]
    ]
end

; ********************************************************************************************************************************************************************
;                                VOTING FUNCTIONS
; ********************************************************************************************************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that casts a vote for a region bus
to cast-vote
  
  ; set threshold for a yes vote (hyperpar)
  let voting_threshold 10
  
  ; calculate empty seats in bus
  let capacity get-capacity bus_type
  let current_passengers length bus_passengers
  let empty_seats capacity - current_passengers
  
  ; if number of empty seats below a certain threshold and the last capacity was above that treshold, vote for a new bus
  ifelse empty_seats <= voting_threshold and last_capacity >= voting_threshold [
    let vote 1
    let message (list "vote" bus_id vote)
    send-message my_region_leader message
    set last_capacity empty_seats
  ]
  [
    ; if empty seats above a certain threshold and last capacity was below that threshold, vote for no new bus
    if empty_seats >= voting_threshold and last_capacity <= voting_threshold [
      let vote 0
      let message (list "vote" bus_id vote)
      send-message my_region_leader message
      set last_capacity empty_seats
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that counts votes (only region leaders use this function)
to count-votes
  let yes_votes sum votes
  let no_votes length votes - yes_votes
  
  ; spawn a new bus if there are at least as many yes votes as there are no votes
  if yes_votes >= no_votes  and spawn_counter >= 30 [
    spawn-region-buses region bus_id
    set spawn_counter 0
  ]
end


; ********************************************************************************************************************************************************************
;                                BIDDING FUNCTIONS
; ********************************************************************************************************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that bids a certain value for a distress stop by sending a message to all freestylers with the bid
; VARIABLES
; bid: float representing the bid for a stop
; stress_stop: the stop the bus is bidding on
to bidding [bid stress_stop]
  let bidding_message (list "bid" bid stress_stop)
  send-to-freestylers bidding_message
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that calculates a bid for a certain stop based on the distance to that stop
; VARIABLES:
; to_stop: distress stop that the bid will be on
to-report calculate-bid [to_stop]
  
  ; get path still to travel
  let path_length length path
  let path_left sublist path path_position path_length
  let distance_current_path get-path-distance path_left
  
  ; get path from last stop to distress stop
  let last_stop current_stop
  if length path > 0 [
    set last_stop last path
  ]
  let new_path dijkstra last_stop to_stop
  let distance_distress_path get-path-distance new_path
  
  ; calc bid
  let bid distance_current_path + distance_distress_path
  
  report bid
end

; ********************************************************************************************************************************************************************
;                                INBOX MANAGEMENT
; ********************************************************************************************************************************************************************

to read-inbox
  
  let inbox_length length inbox
  
  ; read all messages
  while [ inbox_length - 1 > inbox_position ] [
    
    ; update inbox pointer
    set inbox_position inbox_position + 1
    
    ; unpack message
    let full_message item inbox_position inbox
    let tick_sent item 0 full_message
    let sender item 1 full_message
    let message item 2 full_message  
    let message_type item 0 message
    
    ; update latest bus id
    if message_type = "update id" [
      set latest_bus_id item 1 message
    ]
    
    ; initialize buses
    if message_type = "init" [
      ; item 1 is initial_path_type, item 2 is initial_region, item 3 is initial distress stops, item 4 is boolean determining if someone is a region leader
      ;show (list "initial path type" (item 1 message))
      initialize-bus item 1 message item 2 message item 3 message item 4 message item 5 message item 6 message
    ]
    
    ; adding a new leader to region_leader_ids
    if message_type = "new leader" [
      let new_leader_id item 1 message
      if member? new_leader_id region_leader_ids = false [
        set region_leader_ids lput item 1 message region_leader_ids
      ]
    ]
    
    ; received a vote from a region bus, so change it in the voting list
    if message_type = "vote" [
      let voting_bus item 1 message
      let vote item 2 message
      let voting_idx position voting_bus my_buses
      set votes replace-item voting_idx votes vote
    ]
    
    ; received message that there is a new freestyler, so notify colleagues, welcome freestyler with a message telling him who his colleagues are
    if message_type = "new freestyler" [
      
      let free_id item 1 message
      
      ; notify other freestylers
      let notifyer (list "new colleague" free_id)
      send-to-freestylers notifyer
      
      let welcome (list "welcome" freestylers)
      send-message free_id welcome
      
      ; update own list
      set freestylers lput free_id freestylers
      set bids lput 1000000 bids
      set bids_stops lput -1 bids_stops
    ]
    
    ; received message that I have a new colleague freestyler, so add to the list
    if message_type = "new colleague" [
      
      
      let colleague_id item 1 message
      
      ; add him to my list of freestylers
      if member? colleague_id freestylers = false [
        set freestylers lput colleague_id freestylers
        set bids lput 1000000 bids
        set bids_stops lput -1 bids_stops
      ]
      
      ; notify the new freestyler of the current stops in distress
      let add_stops_message (list "add distress stops" distress_stops)
      send-message colleague_id add_stops_message
        
    ]
    
    ; received message containing current stops in distress
    if message_type = "add distress stops" [
      
      let new_distress_stops item 1 message
      set distress_stops new_distress_stops
    ]
    
    ; received distress message from region bus, so add distress stop
    if message_type =  "distress" [
      let new_stop item 1 message
      let extra item 2 message
      add-distress-stop new_stop extra
    ]
    
    ; received welcome message containing colleagues, so add to list
    if message_type = "welcome" [
      let colleagues item 1 message
      add-colleagues colleagues
    ]
    
    ; received message that a freestyler is initialized and ready to go, so send his id to other region leaders
    if message_type = "ready" [
      
      let initialized_freestyler item 1 message
      let new_freestyler_message (list "new freestyler" initialized_freestyler)
      send-to-leaders new_freestyler_message
    ]
    
    ; received message that bus stop is claimed, so remove from distress stops
    if message_type = "claim" [
      let distress_stop item 1 message

      if member? distress_stop distress_stops = true [
        let temp_pos position distress_stop distress_stops
        set distress_stops remove-item temp_pos distress_stops
      ]
    ]
    
    ; received a bid, update bids variable accordingly
    if message_type = "bid" [
      
      ; get bid and stop it is on
      let bid item 1 message
      let stress_stop item 2 message
      
      ; find idx of bus that sent bid and change his bid in the list
      let bidding_idx position sender freestylers
      set bids replace-item bidding_idx bids bid
      set bids_stops replace-item bidding_idx bids_stops stress_stop
    ]
  ]
 
end

to send-to-freestylers [message]
  foreach freestylers [
    let free_id ?
    send-message free_id message
  ]
end

to send-to-leaders [message]
  foreach region_leader_ids [
    let ldr_id ?
    send-message ldr_id message
  ]
end


; ********************************************************************************************************************************************************************
;                                HELPER FUNCTIONS
; ********************************************************************************************************************************************************************

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that calculates the distance of a route
; VARIABLES:
; travel_path: list of stops representing a path / route
to-report get-path-distance [travel_path]
  let total_distance 0
  let idx 1
  foreach travel_path [
    if idx < length travel_path [
      
      let nxt_stop item idx travel_path
      let new_distance get-distance ? nxt_stop
      set total_distance total_distance + new_distance
    ]
    
    set idx idx + 1
  ]
  report total_distance
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that calculates distance of current stop to a destionation
; VARIABLES:
; dest_stop: bus stops denoting destination
to-report get-distance-to-current-stop [dest_stop]
  let temp_dist 0
  ask bus_stop current_stop [ set temp_dist distance id-to-bus-stop dest_stop]

  report temp_dist 
end

to-report id-to-bus-stop [temp_id]
  let temp_busstop "Empty"

  ask bus_stop temp_id [
    set temp_busstop self
  ]

  report temp_busstop
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that adds freestyle bus ids to buses-own variable 'freestylers' and adds a slot in buses-own variables 'bids' and 'bids_stops' for each
; VARIABLES:
; colleagues: list of freestyle colleagues
to add-colleagues [colleagues]
  foreach colleagues [
    if member? ? freestylers = false [
      set freestylers lput ? freestylers
      set bids lput 1000000 bids
      set bids_stops lput -1 bids_stops
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that adds a distress stop to the list if its not already there or moves the stop to the front if it is extra crowded
; VARIABLES:
; stress_stop: bus stop to add
; extra: string denoting whether or not the stop should be moved to the front (if there are more than 90 people waiting)
to add-distress-stop [stress_stop extra]
  
  ifelse member? stress_stop distress_stops = false [
    
    ifelse extra = "extra" [
      set distress_stops lput stress_stop distress_stops
    ]
    [
      set distress_stops fput stress_stop distress_stops
    ]
  ]
  [
    ; if already in list but extra then move to front because a lot of people are waiting there
    if extra = "extra" [
      let current_idx_stop position stress_stop distress_stops
      set distress_stops remove-item current_idx_stop distress_stops
      set distress_stops fput stress_stop distress_stops
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that gets next stop in list path, puts it in buses-own variable 'next_stop' and updates path_position accordingly
to get-next-stop 
  ; get next stop on path and set it in next stop
  let path_length length path
  
  if path_length > 0 [
    let nxt item path_position path
    if current_stop != nxt [
      set next_stop nxt
    ]
    set path_position (path_position + 1) mod path_length
    ;show (list "adding next stop " nxt " path is now " path " and new path_position " path_position)
  ]
  
end

to-report get-capacity [bs_type]

  ; set bus capacity
  let capacity 0
  ifelse bs_type = 1 [
    set capacity 12
  ]
  [   
    ifelse bs_type = 2 [
      set capacity 60
    ]
    [
      set capacity 150
    ]
  ]
  report capacity
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; function that drops people off and picks new people up ONLY IF: people are on the path of the bus (future path if bus is freestyler)
; VARIABLES:
; cur_bus_stop: current bus stop
; cur_bus_passengers: current passengers in bus
; capacity: current capacity
to-report drop-and-pick [cur_bus_stop cur_bus_passengers cur_bus_id capacity]
  
  ; current number of passengers
  let n_passengers length cur_bus_passengers

  ; get passengers waiting at current bus stop
  let waiting_passengers get-passengers-at-stop cur_bus_stop

  ; drop off people who want to go out at current stop
  foreach cur_bus_passengers [
    if item 1 ? = cur_bus_stop [
      drop-off-passenger item 0 ?
    ]  
  ]
   
  let still_at_stop []

  ; then get people that are waiting and are on the path
  foreach waiting_passengers [

    if n_passengers < capacity [
      let passenger_destination item 1 ?
      let is_on_path false

      ; iterate through the bus path to find if passengers' destination is on the path 
      foreach path [ 
        ; for freestylers, only consider the FUTURE stops in the path because they do not repeat the path
        if path_type = "fixed" or position ? path >= path_position [
          if passenger_destination = ? [
            set is_on_path true
          ]
        ]
      ]
      ; if the passenger is on the path -> pick him/her up
      ifelse is_on_path = true [
        pick-up-passenger item 0 ?
        set n_passengers n_passengers + 1
      ]
      [
        set still_at_stop lput ? still_at_stop
      ]
    ] 
  ]
  report still_at_stop
end

; ********************************************************************************
;                                PATH FINDING
; ********************************************************************************
to-report dijkstra [cur_stop claimed_stop]
  let shortest_path [] 
  let path_temp []
  ask bus_stop cur_stop [ set shortest_path nw:turtles-on-weighted-path-to bus_stop claimed_stop "route_size" ]

  ; convert turtles to id's
  foreach shortest_path [
    ask ? [
      let id_temp bus_stop_name_to_id name
      set path_temp lput id_temp path_temp
    ]
  ]
  ;show (list "finding path between " cur_stop " and " claimed_stop " found path: " path_temp)
  report path_temp
end

to-report bus_stop_name_to_id [ string_name ]
  let id position string_name amsterdam_bus_stops_names

  report id
end

; ********************************************************************************************************************************************************************
;                                TODO
; ********************************************************************************************************************************************************************
; is it alowed to say something like if bus = 24 init...?

; TODO
; add voting on freestylers (optionally)
; note: when submitting final, change the color to what it was previously
